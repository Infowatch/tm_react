# Signals    = require "signals"
# Action = require "core/action"
# dispatcher = require "core/dispatcher"

# Signal = Signals.Signal

# class Store

#   # all stores
#   instancies = {}

#   @getInstance = ->
#     instance = instancies[@name] ?= (new @)

#   @on = (action, handler) ->
#     name = [@name, action].join "."
#     i = @getInstance()
#     i.constructor.handlers[name] = handler
#     i.actions[action] = Action name

#   @dependOn = (stores...) ->
#     @instance().dependencies = stores

#   constructor: ->

#     # realize singleton
#     if _.has instancies, @constructor.name
#       return instancies[@constructor.name]

#     @actions = {}
#     @onChange = (callback) =>
#       Store.onChange(@) callback

#     @initialize.apply @constructor

#   initialize: ->
#     @handlers     = {}
#     @dependencies = []
#     @changed      = new Signal

#     @register = ->
#         dispatcher.register @constructor

#     @unregister = ->
#         dispatcher.unregister @constructor

#     @_handleAction = (actionName, payload) ->

#       handler = undefined
#       result = undefined

#       # If this store subscribed to that action
#       if actionName in @handlers
#         handler = @handlers[actionName]
#         # handlers are optional

#         if handler
#           dispatcher.waitFor.apply null, dependencies
#           result = handler(payload)

#         if result != false
#           @changed.dispatch()

#     @register()

#   @onChange = ->

#     stores = arguments
#     # curried, to separate the stores from the callback.
#     (callback) ->
#       count = 0

#       inc = ->
#         count += 1

#       started = ->
#         count = 0

#       stopped = ->
#         if count
#           callback()

#       i = 0
#       while i < stores.length
#         stores[i].changed.add inc
#         i++
#       dispatcher.started.add started
#       dispatcher.stopped.add stopped

#       ->
#         dispatcher.started.remove started
#         dispatcher.stopped.remove stopped
#         i = 0
#         while i < stores.length
#           stores[i].changed.remove inc
#           i++

# module.exports = Store

Signal = require('signals').Signal
dispatcher = require('core/dispatcher')

###*
* Creates and register a new store.
###

Store = (factory) ->
  handlers = {}
  dependencies = []
  waitFor = undefined

  listen = (action, handler) ->
    handlers[action] = handler
    return

  dependOn = ->
    dependencies = Array::slice.call(arguments)
    return

  instance = factory(listen, dependOn) or {}

  dispatcher.register instance

  instance._handleAction = (actionName, payload) ->
    handler = undefined
    result = undefined
    # If this store subscribed to that action
    if actionName in handlers
      handler = handlers[actionName]
      # handlers are optional
      if handler
        dispatcher.waitFor.apply null, dependencies
        result = handler(payload)
      if result != false
        instance.changed.dispatch()
    return

  instance.unregister = ->
    dispatcher.unregister instance
    return

  instance.changed = new Signal
  instance


###*
* Calls a function if any of the passed
* stores changed during one dispatcher run.
###

Store.onChange = ->
  stores = arguments
  # curried, to separate the stores from the callback.
  (callback) ->
    count = 0

    inc = ->
      count += 1
      return

    started = ->
      count = 0
      return

    stopped = ->
      if count
        callback()
      return

    i = 0
    while i < stores.length
      stores[i].changed.add inc
      i++
    dispatcher.started.add started
    dispatcher.stopped.add stopped
    ->
      `var i`
      dispatcher.started.remove started
      dispatcher.stopped.remove stopped
      i = 0
      while i < stores.length
        stores[i].changed.remove inc
        i++
      return

module.exports = Store

# ---
# generated by js2coffee 2.0.0
